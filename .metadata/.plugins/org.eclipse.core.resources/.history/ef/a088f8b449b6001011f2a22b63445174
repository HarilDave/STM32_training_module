/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "STM32_L0538xx.h"
#include "gpio_driver.h"
#include "spi_driver.h"
#include "uart_driver.h"
#include "I2c_driver.h"


/*////// GPIO driver
int main(void)
{
    GPIO_Config_t led;

    led.PinNumber = GPIO_PIN_4;
    led.Mode      = GPIO_MODE_OUTPUT;
    led.Pull      = GPIO_NO_PUPD;
    led.Speed     = GPIO_SPEED_LOW;
    led.OType     = GPIO_OTYPE_PP;
    led.AltFunc   = 0;

    GPIO_Init(GPIOB, &led);

    while(1)
    {
        GPIO_TogglePin(GPIOB, GPIO_PIN_4);
        for(volatile uint32_t i = 0; i < 50000; i++);
    }
}
 */



/////////SPI Driver

SPI_Handle_t hspi1;
GPIO_Config_t spi_gpio;

int main(void)
{
    /* Enable GPIOA clock */
    RCC->IOPENR |= (1 << 0);

    /* Enable SPI1 clock */
    SPI1_PCLK_EN();

    /* ==== SPI GPIO Config ==== */
    spi_gpio.Mode = GPIO_MODE_ALTFN;
    spi_gpio.AltFunc = 0; // AF0 for SPI1
    spi_gpio.Pull = GPIO_NOPULL;
    spi_gpio.Speed = GPIO_SPEED_HIGH;

    spi_gpio.PinNumber = GPIO_PIN_5; // SCK
    GPIO_Init(GPIOA, &spi_gpio);

    spi_gpio.PinNumber = GPIO_PIN_6; // MISO
    GPIO_Init(GPIOA, &spi_gpio);

    spi_gpio.PinNumber = GPIO_PIN_7; // MOSI
    GPIO_Init(GPIOA, &spi_gpio);

    /* ==== CS pin ==== */
    spi_gpio.Mode = GPIO_MODE_OUTPUT;
    spi_gpio.PinNumber = GPIO_PIN_4; // NSS
    spi_gpio.Pull = GPIO_NOPULL;
    spi_gpio.Speed = GPIO_SPEED_HIGH;
    GPIO_Init(GPIOA, &spi_gpio);
    GPIO_WritePin(GPIOA, GPIO_PIN_4, 1); // CS HIGH

    /* ==== SPI Config ==== */
    hspi1.pSPIx = SPI1;
    hspi1.SPIConfig.DeviceMode = SPI_DEVICE_MODE_MASTER;
    hspi1.SPIConfig.BusConfig = SPI_BUS_FULL_DUPLEX;
    hspi1.SPIConfig.SclkSpeed = SPI_SCLK_DIV8;
    hspi1.SPIConfig.DFF = SPI_DFF_8BIT;
    hspi1.SPIConfig.CPOL = 0;
    hspi1.SPIConfig.CPHA = 0;
    hspi1.SPIConfig.SSM = SPI_SSM_ENABLE;

    SPI_Init(&hspi1);
    SPI_SSIConfig(SPI1, ENABLE);
    SPI_PeripheralControl(SPI1, ENABLE);

    uint8_t tx = 0x55;
    uint8_t rx = 0x00;

    while (1)
    {
        GPIO_WritePin(GPIOA, GPIO_PIN_4, 0); // CS LOW
        SPI_SendData(SPI1, &tx, 1);
        SPI_ReceiveData(SPI1, &rx, 1);
        GPIO_WritePin(GPIOA, GPIO_PIN_4, 1); // CS HIGH

        for (volatile int i = 0; i < 100000; i++);
    }
}





/*

I2C_Handle_t hi2c1;
GPIO_Config_t i2c_gpio;

int main(void)
{
    RCC->IOPENR |= (1 << 1);   // Enable GPIOB clock

    i2c_gpio.Mode = GPIO_MODE_ALTFN;
    i2c_gpio.AltFunc = 1;       // AF1 for I2C1
    i2c_gpio.Pull = GPIO_NOPULL;
    i2c_gpio.Speed = GPIO_SPEED_HIGH;

    i2c_gpio.PinNumber = GPIO_PIN_6;   // SCL
    GPIO_Init(GPIOB, &i2c_gpio);

    i2c_gpio.PinNumber = GPIO_PIN_7;   // SDA
    GPIO_Init(GPIOB, &i2c_gpio);

    hi2c1.Instance = I2C1;
    hi2c1.Init.ClockSpeed = 100000;
    hi2c1.Init.AddressMode = I2C_7BIT_ADDR;
    hi2c1.Init.OwnAddress = 0x52;
    I2C_Init(&hi2c1);

    uint8_t data[] = "HELLO";
    uint8_t slaveAddr = 0x28;

    while (1)
    {
        I2C_Start(&hi2c1, slaveAddr, I2C_WRITE);

        for (uint8_t i = 0; i < sizeof(data) - 1; i++)
        {
            I2C_WriteData(&hi2c1, data[i]);
        }

        I2C_Stop(&hi2c1);

        for (volatile int i = 0; i < 100000; i++);
    }
}
*/


/*
int main(void)
{
	RCC->IOPENR |= (1 << 0);

	GPIOA->MODER &= ~((3 << (9 * 2)) | (3 << (10 * 2)));   // Clear bits
	GPIOA->MODER |= ((2 << (9 * 2)) | (2 << (10 * 2)));    // AF mode
	GPIOA->AFRH &= ~((0xF << ((9 - 8) * 4)) | (0xF << ((10 - 8) * 4)));  // clear bits
	GPIOA->AFRH |=  ((4 << ((9 - 8) * 4)) | (4 << ((10 - 8) * 4)));      // AF4 (USART1)

	USART1_PCLK_EN();

	UART_Handle_t huart1;
	huart1.pUSARTx = USART1;
	huart1.Init.BaudRate   = 9600;
	huart1.Init.WordLength = 0;    // 8-bit
	huart1.Init.StopBits   = 0;    // 1 stop bit
	huart1.Init.Parity     = 0;    // No parity
	huart1.Init.Mode       = 3;    // TX + RX

	UART_Init(&huart1);

	uint8_t txData[] = "HELLO\r\n";
	uint8_t rxData = 0;
	while (1)
	{
		UART_SendData(&huart1, txData, 7);     // Transmit
		UART_ReceiveData(&huart1, &rxData, 1); // Receive one byte

		if (rxData == 'H')
		{
			GPIOA->MODER |= (1 << (5 * 2)); // Make PA5 output
			GPIOA->ODR ^= (1 << 5);         // Toggle LED
		}

		for (volatile uint32_t i = 0; i < 1000000; i++);
	}
}
*/
