/*
 * spi_driver.c
 *
 *  Created on: Oct 30, 2025
 *      Author: Himshree
 */

#include "spi_driver.h"

void SPI_PeriClockControl(SPI_RegDef_t *pSPIx, uint8_t EnOrDi)
{
	if (EnOrDi)
	{
		if (pSPIx == SPI1) RCC->APB2ENR |= (1 << 12);
		else if (pSPIx == SPI2) RCC->APB1ENR |= (1 << 14);
	}
	else
	{
		if (pSPIx == SPI1) RCC->APB2ENR &= ~(1 << 12);
		else if (pSPIx == SPI2) RCC->APB1ENR &= ~(1 << 14);
	}
}

void SPI_Init(SPI_Handle_t *pSPIHandle)
{
	uint32_t tempreg = 0;


	SPI1->CR1 |= (1 << 8);   // SSM = 1  (software slave management)
	SPI1->CR1 |= (1 << 9);   // SSI = 1  (internal slave select high)
	SPI1->CR1 |= (1 << 6);   // SPE = 1  (enable SPI)


	// Configure device mode
	tempreg |= (pSPIHandle->SPIConfig.DeviceMode << 2);

	// Configure bus config
	if (pSPIHandle->SPIConfig.BusConfig == SPI_BUS_FULL_DUPLEX)
	{
		tempreg &= ~(1 << 15);
	}
	else if (pSPIHandle->SPIConfig.BusConfig == SPI_BUS_HALF_DUPLEX)
	{
		tempreg |= (1 << 15);
	}
	else if (pSPIHandle->SPIConfig.BusConfig == SPI_BUS_SIMPLEX_RX)
	{
		tempreg &= ~(1 << 15);
		tempreg |= (1 << 10);
	}

	// Configure baud rate
	tempreg |= (pSPIHandle->SPIConfig.SclkSpeed << 3);

	// Configure DFF
	tempreg |= (pSPIHandle->SPIConfig.DFF << 11);

	// Configure CPOL and CPHA
	tempreg |= (pSPIHandle->SPIConfig.CPOL << 1);
	tempreg |= (pSPIHandle->SPIConfig.CPHA << 0);

	// Configure SSM
	tempreg |= (pSPIHandle->SPIConfig.SSM << 9);

	pSPIHandle->pSPIx->CR1 = tempreg;
}

void SPI_DeInit(SPI_RegDef_t *pSPIx)
{
	if (pSPIx == SPI1) RCC->APB2RSTR |= (1 << 12);
	else if (pSPIx == SPI2) RCC->APB1RSTR |= (1 << 14);
}

void SPI_Enable(SPI_RegDef_t *pSPIx, uint8_t EnOrDi)
{
	if (EnOrDi)
		pSPIx->CR1 |= (1 << 6);   // Enable SPI
	else
		pSPIx->CR1 &= ~(1 << 6);  // Disable SPI
}

void SPI_ClockControl(SPI_RegDef_t *pSPIx, uint8_t EnOrDi)
{
	if (EnOrDi == ENABLE)
	{
		if (pSPIx == SPI1) RCC->APB2ENR |= (1 << 12);
		else if (pSPIx == SPI2) RCC->APB1ENR |= (1 << 14);
	}
	else
	{
		if (pSPIx == SPI1) RCC->APB2ENR &= ~(1 << 12);
		else if (pSPIx == SPI2) RCC->APB1ENR &= ~(1 << 14);
	}
}




uint8_t SPI_GetFlagStatus(SPI_RegDef_t *pSPIx, uint32_t FlagName)
{
	if (pSPIx->SR & FlagName)
		return 1;
	return 0;
}

void SPI_SendData(SPI_RegDef_t *pSPIx, uint8_t *pTxBuffer, uint32_t Len)
{
	while (Len > 0)
	{
		while (!SPI_GetFlagStatus(pSPIx, SPI_TXE_FLAG));
		pSPIx->DR = *pTxBuffer;
		pTxBuffer++;
		Len--;
	}
	while (SPI_GetFlagStatus(pSPIx, SPI_BSY_FLAG));
}

void SPI_ReceiveData(SPI_RegDef_t *pSPIx, uint8_t *pRxBuffer, uint32_t Len)
{
	while (Len > 0)
	{
		while (!SPI_GetFlagStatus(pSPIx, SPI_RXNE_FLAG));
		*pRxBuffer = pSPIx->DR;
		pRxBuffer++;
		Len--;
	}
}

void SPI_SSIConfig(SPI_RegDef_t *pSPIx, uint8_t EnOrDi)
{
	if (EnOrDi == ENABLE)
	{
		pSPIx->CR1 |= (1 << SPI_CR1_SSI);
	}
	else
	{
		pSPIx->CR1 &= ~(1 << SPI_CR1_SSI);
	}
}


//////////////////////////               DMA

void SPI1_DMA_Init(uint8_t *txBuf, uint8_t *rxBuf, uint16_t size)
{
    RCC->IOPENR |= (1 << 0);
    RCC->APB2ENR |= (1 << 12);
    RCC->AHBENR  |= (1 << 0);

    GPIOA->MODER &= ~((3 << (5 * 2)) | (3 << (6 * 2)) | (3 << (7 * 2)));
    GPIOA->MODER |=  ((2 << (5 * 2)) | (2 << (6 * 2)) | (2 << (7 * 2)));
    GPIOA->AFRL  &= ~((0xF << (5 * 4)) | (0xF << (6 * 4)) | (0xF << (7 * 4)));
    GPIOA->AFRL  |=  ((0x0 << (5 * 4)) | (0x0 << (6 * 4)) | (0x0 << (7 * 4)));

    GPIOA->MODER &= ~(3 << (4 * 2));
    GPIOA->MODER |=  (1 << (4 * 2));
    GPIOA->ODR    |=  (1 << 4);

    SPI1->CR1 = (1 << 2) | (3 << 3) | (1 << 8) | (1 << 9);
    SPI1->CR2 = (1 << 0) | (1 << 1);
    SPI1->CR1 |= (1 << 6);

    DMA1_Channel2->CCR = 0;
    DMA1_Channel3->CCR = 0;

    DMA1_Channel2->CPAR = (uint32_t)&SPI1->DR;
    DMA1_Channel2->CMAR = (uint32_t)txBuf;
    DMA1_Channel2->CNDTR = size;
    DMA1_Channel2->CCR = (1 << 4) | (1 << 7) | (1 << 1);

    DMA1_Channel3->CPAR = (uint32_t)&SPI1->DR;
    DMA1_Channel3->CMAR = (uint32_t)rxBuf;
    DMA1_Channel3->CNDTR = size;
    DMA1_Channel3->CCR = (1 << 5) | (1 << 7) | (1 << 0);
}

void SPI1_DMA_Start(void)
{
    DMA1_Channel3->CCR |= 1;
    DMA1_Channel2->CCR |= 1;
    GPIOA->ODR &= ~(1 << 4);
}

void SPI1_DMA_Stop(void)
{
    GPIOA->ODR |= (1 << 4);
    DMA1_Channel2->CCR &= ~1;
    DMA1_Channel3->CCR &= ~1;
}
