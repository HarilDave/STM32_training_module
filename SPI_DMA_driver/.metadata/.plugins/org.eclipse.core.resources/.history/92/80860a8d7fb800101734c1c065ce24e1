/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "spi_driver.h"
#include "gpio_driver.h"


/* global SPI handle */
SPI_Handle_t spi1Handle;

/* dummy TX/RX buffers */
uint8_t txData[] = { 0x55, 0xAA, 0x77, 0x99 };
uint8_t rxData[4];

void GPIO_Config(void)
{
    RCC->IOPENR |= (1 << 0);      // Enable GPIOA clock

    // PA5 - SCK, PA6 - MISO, PA7 - MOSI
    GPIOA->MODER &= ~((3 << (5 * 2)) | (3 << (6 * 2)) | (3 << (7 * 2)));
    GPIOA->MODER |= ((2 << (5 * 2)) | (2 << (6 * 2)) | (2 << (7 * 2))); // Alternate function

    GPIOA->AFR[0] &= ~((0xF << (5 * 4)) | (0xF << (6 * 4)) | (0xF << (7 * 4)));
    GPIOA->AFR[0] |= ((0x0 << (5 * 4)) | (0x0 << (6 * 4)) | (0x0 << (7 * 4))); // AF0 for SPI1
}

static void SPI1_Config(void)
{
    spi1Handle.pSPIx = SPI1;
    spi1Handle.SPIConfig.DeviceMode = SPI_MASTER_MODE;
    spi1Handle.SPIConfig.BusConfig = SPI_BUS_FULL_DUPLEX;
    spi1Handle.SPIConfig.SclkSpeed = SPI_SCLK_DIV8;
    spi1Handle.SPIConfig.DFF = SPI_DFF_8BIT;
    spi1Handle.SPIConfig.CPOL = SPI_CPOL_LOW;
    spi1Handle.SPIConfig.CPHA = SPI_CPHA_LOW;
    spi1Handle.SPIConfig.SSM  = SPI_SSM_EN;

    SPI_PeriClockControl(SPI1, 1);
    SPI_Init(&spi1Handle);
}

/* DMA1 channels 2 (RX) and 3 (TX) for SPI1 */
static void SPI1_DMA_Config(void)
{
    spi1Handle.DMACfg.pDMA_TxAddr = (uint32_t)DMA1_Channel3;
    spi1Handle.DMACfg.pDMA_RxAddr = (uint32_t)DMA1_Channel2;

    SPI_DMA_TxInit(&spi1Handle, txData, sizeof(txData));
    SPI_DMA_RxInit(&spi1Handle, rxData, sizeof(rxData));

    SPI_DMA_Enable(&spi1Handle);
}

/* dummy small delay loop */
static void delay_ms(uint32_t ms)
{
    for (volatile uint32_t i = 0; i < (ms * 800U); i++);
}

int main(void)
{
    GPIO_Config();
    SPI1_Config();
    SPI1_DMA_Config();

    /* wait for DMA transfer to complete (poll BSY flag) */
    while (SPI_GetFlagStatus(spi1Handle.pSPIx, SPI_BSY_FLAG));

    SPI_DMA_Disable(&spi1Handle);

    while (1)
    {
        delay_ms(1000);
        /* at this point rxData should contain received bytes */
    }
}

