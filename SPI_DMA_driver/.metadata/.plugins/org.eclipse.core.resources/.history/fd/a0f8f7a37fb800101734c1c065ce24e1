/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "spi_driver.h"
#include "gpio_driver.h"


/* global SPI handle */
SPI_Handle_t spi1Handle;

/* dummy TX/RX buffers */
uint8_t txData[] = { 0x55, 0xAA, 0x77, 0x99 };
uint8_t rxData[4];

static void GPIO_Config(void)
{
    /* Enable GPIOA clock */
    RCC->IOPENR |= (1U << 0);

    /* SPI1 pins:
       PA5 -> SCK
       PA6 -> MISO
       PA7 -> MOSI
       Alternate Function 0 (AF0 = SPI1)
    */
    GPIOA->MODER &= ~((3U<<(5*2)) | (3U<<(6*2)) | (3U<<(7*2)));
    GPIOA->MODER |=  ((2U<<(5*2)) | (2U<<(6*2)) | (2U<<(7*2)));
    GPIOA->AFR[0] &= ~((0xF<<(5*4)) | (0xF<<(6*4)) | (0xF<<(7*4)));
}

static void SPI1_Config(void)
{
    spi1Handle.pSPIx = SPI1;
    spi1Handle.SPIConfig.DeviceMode = SPI_MASTER_MODE;
    spi1Handle.SPIConfig.BusConfig = SPI_BUS_FULL_DUPLEX;
    spi1Handle.SPIConfig.SclkSpeed = SPI_SCLK_DIV8;
    spi1Handle.SPIConfig.DFF = SPI_DFF_8BIT;
    spi1Handle.SPIConfig.CPOL = SPI_CPOL_LOW;
    spi1Handle.SPIConfig.CPHA = SPI_CPHA_LOW;
    spi1Handle.SPIConfig.SSM  = SPI_SSM_EN;

    SPI_PeriClockControl(SPI1, 1);
    SPI_Init(&spi1Handle);
}

/* DMA1 channels 2 (RX) and 3 (TX) for SPI1 */
void SPI1_DMA_Config(void)
{
    RCC->AHBENR |= RCC_AHBENR_DMA1EN;

    spi1Handle.DMACfg.pDMA_Tx = DMA1_Channel3; // SPI1_TX
    spi1Handle.DMACfg.pDMA_Rx = DMA1_Channel2; // SPI1_RX

    spi1Handle.DMACfg.pDMA_Tx->CCR = 0;
    spi1Handle.DMACfg.pDMA_Rx->CCR = 0;

    spi1Handle.DMACfg.pDMA_Tx->CCR |= (1 << 7) | (1 << 4); // MEM2MEM disable, MINC enable
    spi1Handle.DMACfg.pDMA_Rx->CCR |= (1 << 7) | (1 << 4); // MINC enable

    spi1Handle.pSPIx->CR2 |= (1 << 1) | (1 << 0); // TXDMAEN, RXDMAEN
}

/* dummy small delay loop */
static void delay_ms(uint32_t ms)
{
    for (volatile uint32_t i = 0; i < (ms * 800U); i++);
}

int main(void)
{
    GPIO_Config();
    SPI1_Config();
    SPI1_DMA_Config();

    /* wait for DMA transfer to complete (poll BSY flag) */
    while (SPI_GetFlagStatus(spi1Handle.pSPIx, SPI_BSY_FLAG));

    SPI_DMA_Disable(&spi1Handle);

    while (1)
    {
        delay_ms(1000);
        /* at this point rxData should contain received bytes */
    }
}

