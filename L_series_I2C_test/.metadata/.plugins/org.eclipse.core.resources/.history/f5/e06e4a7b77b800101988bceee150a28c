/*
 * i2c.c
 *
 *  Created on: Oct 30, 2025
 *      Author: Himshree
 */


#include <I2c_driver.h>

void I2C_Init(I2C_Handle_t *hi2c)
{
    if(hi2c->Instance == I2C1)
        RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;
    else if(hi2c->Instance == I2C2)
        RCC->APB1ENR |= RCC_APB1ENR_I2C2EN;

    hi2c->Instance->CR1 &= ~I2C_CR1_PE;
    hi2c->Instance->TIMINGR = 0x2000090E;   // ~100kHz @ 16MHz
    hi2c->Instance->OAR1 = (hi2c->Init.OwnAddress & 0x3FF) | I2C_OAR1_OA1EN;
    hi2c->Instance->CR2 = 0;
    hi2c->Instance->CR1 |= I2C_CR1_PE;
}

void I2C_Start(I2C_Handle_t *hi2c, uint8_t address, uint8_t direction, uint8_t numBytes)
{
    // Clear previous settings
    hi2c->Instance->CR2 &= ~(I2C_CR2_SADD | I2C_CR2_NBYTES |
                             I2C_CR2_RD_WRN | I2C_CR2_START | I2C_CR2_STOP);

    // Set address, number of bytes, and direction
    hi2c->Instance->CR2 |= ((uint32_t)address << 1) |
                           ((uint32_t)numBytes << 16);

    if (direction == I2C_READ)
        hi2c->Instance->CR2 |= I2C_CR2_RD_WRN;   // Read mode

    // Generate START condition
    hi2c->Instance->CR2 |= I2C_CR2_START;

    // Wait until ready to send or NACK received
    while (!(hi2c->Instance->ISR & (I2C_ISR_TXIS | I2C_ISR_NACKF)));
}

void I2C_Stop(I2C_Handle_t *hi2c)
{
    // Generate STOP condition
    hi2c->Instance->CR2 |= I2C_CR2_STOP;

    // Wait until STOP flag is set
    while (!(hi2c->Instance->ISR & I2C_ISR_STOPF));

    // Clear STOP flag
    hi2c->Instance->ICR |= I2C_ICR_STOPCF;
}


void I2C_WriteData(I2C_Handle_t *hi2c, uint8_t data)
{
    while(!(hi2c->Instance->ISR & I2C_ISR_TXIS));
    hi2c->Instance->TXDR = data;
}

uint8_t I2C_ReadData(I2C_Handle_t *hi2c)
{
    while(!(hi2c->Instance->ISR & I2C_ISR_RXNE));
    return (uint8_t)hi2c->Instance->RXDR;
}

void I2C_WaitForFlag(I2C_Handle_t *hi2c, uint32_t flag)
{
    while(!(hi2c->Instance->ISR & flag));
}
