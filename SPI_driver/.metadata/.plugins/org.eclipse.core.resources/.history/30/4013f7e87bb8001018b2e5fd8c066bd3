/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "spi_driver.h"
#include "gpio_driver.h"
/////////SPI Driver

SPI_Handle_t hspi1;
GPIO_Config_t spi_gpio;
int main(void)
{
    // Enable GPIOA and SPI1 clocks
    RCC->IOPENR |= (1 << 0);
    RCC->APB2ENR |= (1 << 12);

    // Configure PA5 = SCK, PA6 = MISO, PA7 = MOSI (AF0)
    GPIOA->MODER &= ~((3 << (5 * 2)) | (3 << (6 * 2)) | (3 << (7 * 2)));
    GPIOA->MODER |=  ((2 << (5 * 2)) | (2 << (6 * 2)) | (2 << (7 * 2)));
    GPIOA->AFRL  &= ~((0xF << (5 * 4)) | (0xF << (6 * 4)) | (0xF << (7 * 4)));
    GPIOA->AFRL  |=  ((0x0 << (5 * 4)) | (0x0 << (6 * 4)) | (0x0 << (7 * 4)));

    // Configure PA4 = NSS (software control)
    GPIOA->MODER &= ~(3 << (4 * 2));
    GPIOA->MODER |=  (1 << (4 * 2));
    GPIOA->ODR    |=  (1 << 4);  // CS high

    // SPI1 configuration: Master, 8-bit, SSM=1, SSI=1, fPCLK/8
    SPI1->CR1 = 0;
    SPI1->CR1 |= (1 << 2);   // Master
    SPI1->CR1 |= (3 << 3);   // BR[2:0] = 011 -> fPCLK/8
    SPI1->CR1 |= (1 << 8);   // SSM enable
    SPI1->CR1 |= (1 << 9);   // SSI high
    SPI1->CR1 |= (1 << 6);   // SPE enable

    uint8_t tx = 0x55;
    volatile uint8_t rx = 0x00;

    while (1)
    {
        GPIOA->ODR &= ~(1 << 4); // NSS low

        while (!(SPI1->SR & (1 << 1)));  // Wait TXE
        *((__IO uint8_t *)&SPI1->DR) = tx;

        while (!(SPI1->SR & (1 << 0)));  // Wait RXNE
        rx = *((__IO uint8_t *)&SPI1->DR);

        GPIOA->ODR |= (1 << 4); // NSS high

        for (volatile int i = 0; i < 100000; i++);

        // Optional LED toggle on PA5 for debug if data matched
        if (rx == 0xAA)
        {
            GPIOA->ODR ^= (1 << 5);
        }
    }
}
